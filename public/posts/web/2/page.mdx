---
title: 로그만 찍어봤는데, 성능이 떨어져요.
date: 2025/02/24
description:
tags: []
author: 이진용
---

백준이나 프로그래머스에서 코딩테스트를 준비해본 경험이 있을까요?

해당 PS 사이트에서는 알고리즘의 효율성을 기준으로 점수를 매기게 되는데요,

- 시간 복잡도 : 얼마나 적은 연산을 했나

- 공간 복잡도 : 얼마나 적은 메모리를 사용했나

문제를 풀다보면 이런 상황이 생길 때가 있어요.

### 문제 상황

```python
def solution(n, stations, w):
    answer = 0
    start = 1

    for station in stations:
        count = station - w - start
        if count > 0:
            answer += math.ceil(count / (2 * w + 1))
        start = station + w + 1

    if start <= n:
        count = n - start + 1
        answer += math.ceil(count / (2 * w + 1))

    return answer

```

가끔 디버깅을 위해 print 출력 코드를 남겨놓은 채로 답을 제출하면, 이런 결과를 확인하게 되는데요,

![](/posts/2/Pasted_image_20250225001323.png)

프로그래머스를 기준으로 좌측이 실행시간, 우측이 메모리 사용량을 의미해요.

print 코드를 제거하고 다시 제출을 해보면 다음과 같아요.

![](/posts/2/Pasted_image_20250225001339.png)

### 결과

실행 시간이 절반 넘개 단축된 것을 확인할 수 있어요. 알고리즘을 변형한 것이 아니라 단순히 **print 하나만 없앴더니 이정도의 성능 향상을 이뤄낸 것이죠!**

왜 이런 일이 일어난걸까요? 한번 하나하나 파헤쳐가 봅시다.

### 가설 1. 파이썬이 너무 느려서 아닐까요?

들어본 말로는 "파이썬은 다른 언어에 비해서 느리다" 라고 들어본 것 같아요.
그럼 같은 로직을 훨씬 빠른 저수준 언어로 작성해볼까요?

```c++
int solution(int n, vector<int> stations, int w)
{
    int answer = 0;

    int start = 1;
    for (int i = 0 ;i < stations.size() ; i++){
        float count = stations[i] - start - w;
        if(count <= 0){
            start = stations[i] +w+1;
            continue;
        }
        cout << count;

        answer += ceil(count/(2*w+1));
        start = stations[i] +w+1;
    }
    cout << start <<endl;
    if(start <= n){
        float count = n - start+1;
        answer += ceil(count/(2*w+1));
    }


    return answer;
}

```

![](/posts/2/Pasted_image_20250225002403.png)

결과를 보면 오히려 **시간 초과가 발생**해 버리네요. 그렇다면 단순히 "파이썬이 느려서" 그런 것은 아닌 것 같아요.

실제로 Python의 구현체 중 가장 유명한 것은 **CPython**으로, 파이썬 코드를 실행하는 **인터프리터는 C로 작성**되어 있어요.

때문에 실제 Python에서 호출된 `print()` 함수는 내부적으로 C의 `printf()` 라이브러리를 거쳐 `write()` 함수를 통해 실행되게 됩니다!

https://stackoverflow.com/questions/59039963/implementation-of-print-in-python

![](/posts/2/Pasted_image_20250225003146.png)

### 가설2. 출력 연산은 다른 연산과 다르게 느린거 아닐까요?

위에서 확인해본 바와 같이 실제로 Python이 실제로 C가 구현체인 write함수를 호출한다는 걸 알았어요.

그럼 이녀석은 왜 다른 연산과 다르게 느린건가요?

해당 내용을 알기 위해선 **system call**이라는 개념을 알아야 해요.
우리가 실행하는 프로그램들은 각각의 프로세스들로 해당 프로세스들을 중앙에서 운영체제가 관리하게 돼요. 운영체제는 각 프로세스들은 각각의 자원들(파일, 메모리, 디스크 ...)을 공유하면서도 다른 프로세스들의 정보는 모르기 때문에 시스템 콜을 사용하여 운영체제에게 확인을 하게 돼요.

우리가 익숙한 출력창도 실제론 stdout이라는 파일로, 우리가 실행하는 프로그램이 해당 파일에 쓰기를 진행하고, 파일에 써진 내용이 출력되는 거죠!

## Context Switching, IO waiting

### 정말 print만 느리네 그럼 다른 것도?

### 실제 개발에서 누가 print가 필요해요?

단순히 디버깅용으로 print를 사용했지만, 실제 개발에서 로깅을 위해 출력함수를 사용할 수밖에 없어요.

### 해결 방법
